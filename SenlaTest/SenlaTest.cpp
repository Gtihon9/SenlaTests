#include "pch.h"
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
int Fib(int i);
void PrimeNumbers();
void fibonacci();
void intersection();
void NODandNOK();
void Polindrom();
void DelNum();
int NOD(int a, int b);
int NOK(int a, int b);

int main()
{
	setlocale(LC_ALL, "Russian");
	DelNum();

}


void PrimeNumbers()
{
	cout << "Задание 1" << endl;
	int N;
	cout << "Введите число N = ";
	cin >> N;
	for (int i = 2; i <= N; i++)
		for (int j = 2; j < i; j++)
		{
			if (i % j == 0)
				break;
			else if (i == j + 1)
				cout << i << " ";
			  
		}
	cout<<endl;
	cout << ". . . . . . . . ." << endl;
	
}

void fibonacci()
{
	cout << "Задание 2" << endl;
	int N;
	cout << "Введите N = ";
	cin >> N;
	int k = 0;
	while (k < N)
	{
		if (Fib(k) < N)
			cout << Fib(k)<< " ";
		else break;
		k++;
	}
	cout << endl;
	cout << ". . . . . . . . ." << endl;

}

void intersection()
{
	cout << "Задание 3" << endl;
	double x1_1, y1_1, x1_2, y1_2, x2_1, y2_1, x2_2, y2_2;
	double x = 0;
	double y = 0;
	cout << "Введите координаты концов первого отрезка в виде x1 y1 x2 y2: ";
	cin >> x1_1 >> y1_1 >> x1_2 >> y1_2;
	cout << "Введите координаты концов второго отрезка: ";
	cin >> x2_1 >> y2_1 >> x2_2 >> y2_2;
	//составляем формулы двух прямых (A1x+B1y+C1, A2x+B2y+C2)
	double A1 = y1_1 - y1_2;
	double B1 = x1_2 - x1_1;
	double C1 = x1_1 * y1_2 - x1_2*y1_1;
	double A2 = y2_1 - y2_2;
	double B2 = x2_2 - x2_1;
	double C2 = x2_1 * y2_2 - x2_2 * y2_1;
	if (B1*A2 - B2 * A1 != 0) //система двух уравнений
	{
		y = (C2*A1 - C1 * A2) / (B1*A2 - B2 * A1);
		x = (-C1 - B1 * y) / A1;
	}
	/*проверяем, находиться ли точка пересечения на первом отрезке, min/max - потому 
	что координаты точки могут быть заданы не по порядку возрастания*/
	if ((min(x1_1, x1_2) <= x <= max(x1_1, x1_2)) && (min(y1_1, y1_2) <= y <= max(y1_1, y1_2)))
		cout << "Координаты пересечения отрезков (" << x << "," << y << ")";
	else
		cout << "Точек пересечения нет" << endl;
	if (B1*A2 - B2 * A1 == 0) //Проверка на параллельность
		cout << "И они парралельны";

	cout << endl;
	cout << ". . . . . . . . ." << endl;
}

void NODandNOK()
{
	cout << "Задание 4" << endl;
	int a, b;
	cout << "Введите первое число:";
	cin >> a;
	cout << "Введите второе число:";
	cin >> b;
	cout << "НОД:" << NOD(a, b) << endl;
	cout << "НОK:" << NOK(a, b) << endl;
	cout << endl;
	cout << ". . . . . . . . ." << endl;
}

void Polindrom()
{
	bool pol = false;
	int end = 0;
	char word[20]="";
	cout << "Задание 5" << endl;
	cout << "Введие слово: ";
	cin >> word;
	int len = strlen(word);
	for (int i = 0; i <= len/2; i++)
	{
		if (word[i] != word[len - i - 1])
			pol = true;
		
	}
	if (pol == true)
		cout << "Не полиндром";
	else
		cout << "Полиндром";
	cout << endl;
	cout << ". . . . . . . . ." << endl;
}

void DelNum()
{
	char word[1000] = "";
	cout << "Задание 5" << endl;
	cout << "Введие техт: ";
	cin >> word;
	int len = strlen(word);
	for (int i = 0; i < len; i++)
	{
		if (word[i] != '0' && word[i] != '1' && word[i] != '2' && word[i] != '3'
			&& word[i] != '4' && word[i] != '5' && word[i] != '6' && word[i] != '7' && word[i] != '8' && word[i] != '9')
		{
			cout << word[i];
		}
	}
	cout << endl;
	cout << ". . . . . . . . ." << endl;
}






int NOD(int a, int b)
{
				/*АЛГОРИТМ ЕВКЛИДА
		1.Большее число делим на меньшее.
		2.Если делится без остатка, то меньшее число и есть НОД(следует выйти из цикла).
		3.Если есть остаток, то большее число заменяем на остаток от деления.
		4.Переходим к пункту 1.*/
	if (b == 0) {
		return a;
	}
	else
		return NOD(a, a%b);
}
int NOK(int a, int b) 
{
	return a / NOD(a, b) * b;
}
int  Fib(int i)
{
	int value = 0;
	if (i < 1) return 0;
	if (i == 1) return 1;
	return Fib(i - 1) + Fib(i - 2);
}



//Задание 1
//Необходимо написать программу, которая вычисляет простые
//числа в пределах от 1 до N.N – вводится вручную во время
//выполнения программы.
//
//Задание 2
//Необходимо написать рекурсивный алгоритм, который находит
//числа Фибоначчи в пределах от 1 до N.N – вводится вручную во
//время выполнения программы.
//
//Задание 3
//Необходимо написать программу, которая определяет
//пересекаются ли два отрезка.Координаты отрезков вводятся
//вручную во время выполнения программы.
//
//Задание 4
//Необходимо написать рекурсивный алгоритм для нахождения НОД
//и НОК двух чисел.Два числа вводятся вручную во время
//выполнения программы.
//
//Задание 5
//Необходимо написать программу, которая проверяет слово на
//"палиндромность".Слово для проверки вводится вручную во
//время выполнения программы.
//
//SENLAINC.COM
//
//Задание 6
//Необходимо написать программу, которая удаляет из текста числа.
//Текст вводится вручную во время выполнения программы.
//
//Технические требования к выполнению заданий
//● Задания должны быть реализованы на любом языке
//программирования.
//● Исходный код решений должен быть выложен в GIT.
//● Скриншоты результатов выполнения программ также
//должны быть выложены в GIT в отдельный каталог.
//● Приветствуется соответствие принципам ООП и сильного
//сцепления.
//● Все сообщения должны быть выведены пользователю в
//консоль, с помощью метода System.out.print(ln).

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
